<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donk Viewer</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <meta name="description" content="" />
    <meta charset="UTF-8">
    <!-- Discord -->
    <meta content="Donk Viewer" property="og:title" />
    <meta content="DK64 Map Viewer with various controls on properties." property="og:description" />
    <meta content="DK64 Utils" property="og:site_name" />
    <meta content="https://raw.githubusercontent.com/theballaam96/theballaam96.github.io/master/assets/head.png" property="og:image" />

    <link rel="stylesheet" href="//code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #info-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.8);
            color: #333;
            border-radius: 5px;
            z-index: 10;
        }
        #versionFlag img {
            width: 24px;
            height: auto;
            vertical-align: middle;
        }
        #trigger_grouping div, #rendering_options div {
            width: 50%;
        }
    </style>
</head>
<body>
    <div id="info-panel">Click a mesh to highlight it.</div>
    <div class="position-absolute top-0 end-0">
        <div class="card p-3 mt-4 me-4 ms-2 mb-2">
            <div class="mb-2">
                <small>ROM File</small>
                <div class="input-group flex-nowrap" id="fileUploadButton">
                    <button class="btn btn-secondary">
                        <i class="fa-solid fa-file-arrow-up"></i>
                    </button>
                    <span class="form-control" id="fileUploadText">Choose a file</span>
                </div>
                <div hidden>
                    <input type="file" id="fileInput" accept=".z64" hidden>
                </div>
            </div>
            <div class="mb-2">
                <label for="map_id_selector">Map</label>
                <select id="map_id_selector" class="form-select"></select>
            </div>
            <div class="mb-2">
                <label for="bg_selector">Backdrop</label>
                <select id="bg_selector" class="form-select"></select>
            </div>
            <div class="mb-2">
                <label for="trigger_grouping">Extra Objects</label>
                <div class="d-flex flex-wrap" id="trigger_grouping">
                    <div class="form-check form-switch py-2">
                        <input class="form-check-input" type="checkbox" role="switch" id="trigger_selector">
                        <label class="form-check-label" for="trigger_selector">Show Triggers</label>
                    </div>
                </div>
            </div>
            <div class="mb-2">
                <label for="rendering_options">Rendering Options</label>
                <div class="d-flex flex-wrap" id="rendering_options">
                    <div class="form-check form-switch py-2">
                        <input class="form-check-input" type="checkbox" role="switch" id="wf_selector">
                        <label class="form-check-label" for="wf_selector">Wireframe Mode</label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://unpkg.com/fflate@0.8.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>
    <script src="https://twemoji.maxcdn.com/v/latest/twemoji.min.js"></script>
    <script src="script/viewer/lib.js" type="text/javascript"></script>
    <script src="script/viewer/ui.js" type="text/javascript"></script>
    <script src="script/viewer/vtx.js" type="text/javascript"></script>
    <script src="script/viewer/parser.js" type="text/javascript"></script>
    <script src="script/viewer/rom_handler.js" type="text/javascript"></script>
    <script src="script/viewer/geometry.js" type="text/javascript"></script>
    <script src="script/viewer/collision.js" type="text/javascript"></script>
    <script src="script/viewer/create_rendered_obj.js" type="text/javascript"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let loadedObject = null;
        let loadedExtras = [];
        let intersected = null;
        const INFO_PANEL = document.getElementById('info-panel');
        const { decompressSync } = fflate;

        // --- Core Functions ---

        async function init() {
            // ROM load
            const isLoaded = await loadStoredFile();
            if (isLoaded) {
                // Stored file was loaded, you can start your application/emulator
                console.log("App ready with loaded data.");
            } else {
                // No stored file, prompt the user to load one
                console.log("App ready, awaiting file selection.");
            }
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333); 
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera.position.set(0, 1, 3);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            scene.add(new THREE.DirectionalLight(0xffffff, 0.4));

            // Raycasting setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event Listeners
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMeshClick);

            // Load a default demo object
            if (isLoaded) {
                window.renderHandler(true);  // Temp
                window.renderHandler(false);
            }
            
            animate();
        }

        function animate() { // <-- The function is defined here
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Demo Model (for immediate testing) ---

        function createDemoCube() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            
            // 1. OPAQUE MESH
            const opaqueMaterial = new THREE.MeshPhongMaterial({ color: 0x4488ff });
            const opaqueMesh = new THREE.Mesh(geometry, opaqueMaterial);
            opaqueMesh.position.x = 1.2;
            opaqueMesh.name = "OpaqueCube";
            
            // 2. TRANSLUCENT MESH (Transparency enabled)
            const translucentMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff4444, 
                opacity: 0.5,           // Set opacity value
                transparent: true,      // ⬅️ MUST be true for transparency
                side: THREE.DoubleSide  // Good practice for translucent objects
            });
            const translucentMesh = new THREE.Mesh(geometry, translucentMaterial);
            translucentMesh.position.x = -1.2;
            translucentMesh.name = "TranslucentCube";
            
            loadedObject = new THREE.Group();
            loadedObject.add(opaqueMesh);
            loadedObject.add(translucentMesh);
            scene.add(loadedObject);
            centerModel();
            INFO_PANEL.textContent = "Demo cubes loaded. Click one!";
        }

        // --- OBJ File Loading ---

        function loadOBJ(objText, resetCamera) {
            // 1. Cleanup previous model (keep this section)
            if (loadedObject) {
                scene.remove(loadedObject);
                loadedObject.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            if (loadedExtras) {
                if (loadedExtras.length > 0) {
                    loadedExtras.forEach(extra => {
                        scene.remove(extra);
                        extra.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    })
                }
                loadedExtras = [];
            }

            try {
                const loader = new THREE.OBJLoader();
                loadedObject = loader.parse(objText);

                // --- CORE FIX FOR VERTEX COLOR SHARING ---
                loadedObject.traverse(function(child) {
                    if (child.isMesh) {
                        const geometry = child.geometry;

                        // 1. Un-Index the Geometry
                        // This forces every face to have its own unique set of vertices,
                        // preventing the GPU from blending colors across the edges.
                        if (geometry.index) {
                            geometry.toNonIndexed(); // Duplicates vertices for hard edges
                        }
                        
                        // 2. Compute Normals (essential after un-indexing for good shading)
                        geometry.computeVertexNormals();

                        // 3. Apply the Material
                        child.material = new THREE.MeshPhongMaterial({ 
                            color: 0xffffff,          // White base color
                            vertexColors: true,       // ⬅️ Keep this, but now the vertices are unique per face
                            transparent: true,        // Enable transparency support
                            opacity: 1.0,             // Default opacity
                            side: THREE.DoubleSide,    // Good for viewing translucent objects
                            wireframe: document.getElementById("wf_selector").checked,
                        });
                        child.name = 'LoadedMesh';
                    }
                });
                // --- END CORE FIX ---
                scene.add(loadedObject);
                if (resetCamera) {
                    centerModel();
                }
                INFO_PANEL.textContent = "OBJ file loaded. Vertex colors are now hard-edged (per-face).";

            } catch (error) {
                console.error("Error parsing OBJ file:", error);
                INFO_PANEL.textContent = "Error loading OBJ: Check console.";
            }
        }
        window.loadOBJ = loadOBJ;

        function addToScene(list) {
            list.forEach(item => {
                scene.add(item);
            })
            loadedExtras = loadedExtras.concat(list);
        }
        window.addToScene = addToScene;
        
        window.rom_bytes;
        window.rom_dv;

        const DB_NAME = 'ROM_Store';
        const STORE_NAME = 'rom_data';
        const KEY = 'current_rom';
        const DB_VERSION = 1;

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.errorCode);
                    reject("Database error");
                };

                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };

                // This runs only when the DB is first created or the version is upgraded
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    // Create an object store to hold the ROM data
                    db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                };
            });
        }

        function setGlobalRomData(arrayBuffer) {
            window.rom_bytes = new Uint8Array(arrayBuffer);
            window.rom_dv = new DataView(arrayBuffer);
            detectVersion(window.rom_bytes);
            console.log("Global ROM data updated.");
        }

        async function loadStoredFile() {
            try {
                const db = await openDB();
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                
                const request = store.get(KEY);
                
                return new Promise((resolve) => {
                    request.onsuccess = (event) => {
                        const result = event.target.result;
                        if (result && result.data) {
                            console.log("Found stored file data. Loading...");
                            setGlobalRomData(result.data);
                            resolve(true);
                        } else {
                            console.log("No stored file data found.");
                            resolve(false);
                        }
                    };

                    request.onerror = (event) => {
                        console.error("Error loading data:", event.target.error);
                        resolve(false);
                    };
                });

            } catch (e) {
                console.error("IndexedDB operation failed during load:", e);
                return false;
            }
        }

        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const arrayBuffer = await file.arrayBuffer();

            setGlobalRomData(arrayBuffer);

            try {
                const db = await openDB();
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);

                const dataToStore = { 
                    id: KEY, 
                    data: arrayBuffer 
                };

                const request = store.put(dataToStore);

                request.onsuccess = () => {
                    console.log("File data (", (arrayBuffer.byteLength / (1024 * 1024)).toFixed(2), "MB) stored successfully in IndexedDB.");
                };

                request.onerror = (event) => {
                    console.error("Error storing data:", event.target.error);
                    alert("Could not store file in browser. The browser may have run out of storage space.");
                };

            } catch (e) {
                console.error("IndexedDB operation failed:", e);
            }

            window.rom_bytes = new Uint8Array(arrayBuffer);
            window.detectVersion(window.rom_bytes);
            window.rom_dv = new DataView(arrayBuffer);
            window.renderHandler(false);
            window.renderHandler(false);
        }

        // --- Interaction (Clickable Meshes) ---

        function onMeshClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Determine objects to check (all children of the loaded object)
            const intersects = raycaster.intersectObjects(loadedObject ? loadedObject.children : [], true);

            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;

                // Reset previous selection and highlight new selection...
                // ...

                // CORRECTED CODE: Calculate triangle count safely
                let triangleCount;
                if (hitMesh.geometry.index) {
                    // If the geometry is indexed (most common for complex models)
                    triangleCount = hitMesh.geometry.index.count / 3;
                } else if (hitMesh.geometry.attributes.position) {
                    // If the geometry is not indexed, use the position attribute count
                    triangleCount = hitMesh.geometry.attributes.position.count / 3;
                } else {
                    triangleCount = 'N/A';
                }

                // Update info panel
                INFO_PANEL.textContent = `Clicked Mesh: ${hitMesh.name || 'No Name'} | Triangles: ${triangleCount}`;

            } else {
                // No object hit, deselect
                if (intersected && intersected.material.emissive) {
                    intersected.material.emissive.setHex(0x000000);
                }
                intersected = null;
                INFO_PANEL.textContent = "Click a mesh to highlight it.";
            }
        }

        // --- Utility Functions ---
        
        function centerModel() {
            if (!loadedObject) return;
            
            const box = new THREE.Box3().setFromObject(loadedObject);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            // Center model and put it on the plane (Y=0)
            loadedObject.position.sub(center).add(new THREE.Vector3(0, size.y / 2, 0));
            
            // Adjust camera to view the model
            controls.target.copy(loadedObject.position);
            const distance = Math.max(size.x, size.y, size.z) * 1.5;
            camera.position.copy(loadedObject.position).add(new THREE.Vector3(0, size.y * 0.5, distance));
            controls.update();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize the application
        init();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
</body>
</html>