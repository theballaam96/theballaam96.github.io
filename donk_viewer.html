<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donk Viewer</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <meta name="description" content="" />
    <meta charset="UTF-8">
    <!-- Discord -->
    <meta content="Donk Viewer" property="og:title" />
    <meta content="DK64 Map Viewer with various controls on properties." property="og:description" />
    <meta content="DK64 Utils" property="og:site_name" />
    <meta content="https://raw.githubusercontent.com/theballaam96/theballaam96.github.io/master/assets/head.png" property="og:image" />

    <link rel="stylesheet" href="//code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #versionFlag img {
            width: 24px;
            height: auto;
            vertical-align: middle;
        }
        #trigger_grouping div, #rendering_options div {
            width: 50%;
        }
        .marker-collapse {
            transition: 0.2s ease-in-out;
        }
        .marker-collapse[aria-expanded=true] {
            transform: rotate(90deg);
        }
        input[type="color"] {
            -webkit-appearance: none; /* Chrome/Safari */
            appearance: none;         /* modern browsers */
            border: 1px solid #777;             /* remove outer border */
            padding: 0;
            width: 40px;              /* change size as needed */
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            background: transparent;  /* ensure no extra bg */
            cursor: pointer;
            vertical-align: middle;
        }

        /* Remove inner default swatch styling in WebKit */
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 50%;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }

        /* Firefox */
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 50%;
        }

        /* Optional: nicer keyboard focus (keep for accessibility) */
        input[type="color"]:focus {
            outline: none;
        }
        input[type="color"]:focus-visible {
            box-shadow: 0 0 0 3px rgba(0,123,255,0.35);
        }
    </style>
</head>
<body>
    <div class="position-fixed" style="width: 100%; height: 100%; z-index: 2000; background-color: #222; transition: 0.5s ease-in-out;" id="ftt_splash">
        <div class="position-relative" style="height: 100%;">
            <div class="position-absolute top-50 start-50 translate-middle">
                <div style="max-width: 600px" class="card p-4 text-center" id="ftt_warning" hidden>
                    <h1>Welcome to DonkViewer</h1>
                    <p class="mt-4">
                        DonkViewer is a utility for viewing the maps and objects within Donkey Kong 64, allowing to view 
                        hidden aspects of the game such as collision, the path for Beetle Races and invisible triggers. 
                        This also supports all 5 known versions of the game.
                    </p>
                    <p>
                        That being said, DonkViewer requires the user to supply their own ROM to generate the views. 
                        DonkViewer will store this on your browser so you don't have to see this notice every time.
                    </p>
                    <button class="btn btn-primary mt-4" id="upload_rom_ftt">
                        Upload your ROM
                    </button>
                </div>
            </div>
        </div>
    </div>
    <div class="position-absolute bottom-0 start-0">
        <div class="card p-2 ms-2 mb-2 me-2 d-none" id="extra_data">
            <div class="d-flex pb-1" style="border-bottom: 1px solid gray">
                <div id="extra_data_name" class="flex-grow-1 fw-bold me-2"></div>
                <button type="button" class="btn-close" id="extra_data_close" aria-label="Close"></button>
            </div>
            <div id="extra_data_info" class="p-2" style="font-size: 0.8rem"></div>
        </div>
        <div class="card p-2 mb-2 ms-2 me-2 mt-2">
            <div class="d-flex justify-content-between mb-2 pb-1" style="border-bottom: 1px solid gray">
                <div class="fw-bolder">DonkViewer</div>
                <small>v2.2</small>
            </div>
            <div>Made by Ballaam</div>
            <div style="font-size: 0.8rem">Contributions from:
                <ul class="mb-0 ps-3">
                    <li>ALinkToTheFuture</li>
                    <li>ZeldaBoy14</li>
                </ul>
            </div>
        </div>
    </div>
    <div class="position-absolute top-0 start-0">
        <div class="d-flex ms-2 mt-2">
            <div class="card p-2 me-2">
                <ul class="nav nav-pills flex-column" id="myTab" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="main-tab" data-bs-toggle="tab"
                                title="Main Options"
                                data-bs-target="#main-tab-pane" type="button" role="tab"
                                aria-controls="main-tab-pane" aria-selected="true">
                            <i class="fa-solid fa-map"></i>
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="markers-tab" data-bs-toggle="tab"
                                title="Markers"
                                data-bs-target="#markers-tab-pane" type="button" role="tab"
                                aria-controls="markers-tab-pane" aria-selected="false">
                            <i class="fa-solid fa-bezier-curve"></i>
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="rendering-tab" data-bs-toggle="tab"
                                title="Rendering Options"
                                data-bs-target="#rendering-tab-pane" type="button" role="tab"
                                aria-controls="rendering-tab-pane" aria-selected="false">
                            <i class="fa-solid fa-cube"></i>
                        </button>
                    </li>
                </ul>
            </div>
            <div class="card p-3" style="max-width: 500px;" hidden id="tabContent">
                <div class="tab-content">
                    <div class="tab-pane fade" id="main-tab-pane" role="tabpanel" aria-labelledby="main-tab" tabindex="0">
                        <h5>Initial Setup</h5>
                        <hr />
                        <div class="mb-2">
                            <small>ROM File</small>
                            <div class="input-group flex-nowrap" id="fileUploadButton">
                                <button class="btn btn-secondary">
                                    <i class="fa-solid fa-file-arrow-up"></i>
                                </button>
                                <span class="form-control" id="fileUploadText">Choose a file</span>
                            </div>
                            <div hidden>
                                <input type="file" id="fileInput" accept=".z64" hidden>
                            </div>
                        </div>
                        <div class="mb-2">
                            <label for="map_id_selector">Map</label>
                            <select id="map_id_selector" class="form-select change-reload double-reload force-camera"></select>
                        </div>
                        <div class="mb-2">
                            <label for="bg_selector">Backdrop</label>
                            <select id="bg_selector" class="form-select change-reload"></select>
                        </div>
                        <div class="mb-2">
                            <label for="obj_selector">Objects</label>
                            <select id="obj_selector" class="form-select change-reload"></select>
                        </div>
                    </div>
                    <div class="tab-pane fade" id="markers-tab-pane" role="tabpanel" aria-labelledby="markers-tab" tabindex="0">
                        <h5>Markers</h5>
                        <hr />
                        <div class="mb-2">
                            <div id="marker_tree"></div>
                        </div>
                    </div>
                    <div class="tab-pane fade" id="rendering-tab-pane" role="tabpanel" aria-labelledby="rendering-tab" tabindex="0">
                        <h5>Rendering Options</h5>
                        <hr />
                        <div class="mb-2">
                            <div>
                                <div class="form-check form-switch py-2">
                                    <input class="form-check-input click-reload" type="checkbox" role="switch" id="wf_selector">
                                    <label class="form-check-label" for="wf_selector">Wireframe Mode</label>
                                </div>
                                <div class="form-check form-switch py-2">
                                    <input class="form-check-input click-reload force-camera double-reload" type="checkbox" role="switch" id="ortho_camera">
                                    <label class="form-check-label" for="ortho_camera">Orthographic Camera</label>
                                </div>
                                <div class="form-check form-switch py-2">
                                    <input class="form-check-input" type="checkbox" role="switch" id="animate_sprites" checked>
                                    <label class="form-check-label" for="animate_sprites">Animate Sprites</label>
                                </div>
                                <div>
                                    <div>Background Color:</div>
                                    <div>
                                        <input type="color" id="color_picker" value="#333333" />
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="d-flex">
                            <div class="dropdown me-2">
                                <button class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" title="Export Scene">
                                    <i class="fa-solid fa-download"></i>
                                </button>
                                <ul class="dropdown-menu">
                                    <li><a class="dropdown-item" href="#" id="export_obj">To OBJ</a></li>
                                    <li><a class="dropdown-item" href="#" id="export_dae">To DAE</a></li>
                                    <li><a class="dropdown-item" href="#" id="export_glb">To GLB/glTF</a></li>
                                </ul>
                            </div>
                            <button class="btn btn-secondary" title="Snapshot" id="snapshot_scene">
                                <i class="fa-solid fa-camera"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="card p-2 ms-2 d-none" id="gaps_fyi" style="max-width: 500px;">
            <h3>PSA</h3>
            <p>
                This view is experimental and may highlight some gaps that don't exist or miss some gaps that do exist.
                Automatically calculating where the gaps are in complex 3D geometry is an incredibly complicated
                process that this viewer does it's best job at showing. The estimated rate of failure with this viewer is &lt;1%.
            </p>
        </div>
    </div>
    <div class="toast-container position-fixed bottom-0 end-0 p-3" id="toastContainer"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://unpkg.com/fflate@0.8.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>
    <script src="https://twemoji.maxcdn.com/v/latest/twemoji.min.js"></script>
    <script src="script/viewer/lib.js" type="text/javascript"></script>
    <script src="script/viewer/texture.js" type="text/javascript"></script>
    <script src="script/viewer/toast.js" type="text/javascript"></script>
    <script src="script/viewer/ui.js" type="text/javascript"></script>
    <script src="script/viewer/vtx.js" type="text/javascript"></script>
    <script src="script/viewer/parser.js" type="text/javascript"></script>
    <script src="script/viewer/rom_handler.js" type="text/javascript"></script>
    <script src="script/viewer/fluids.js" type="text/javascript"></script>
    <script src="script/viewer/geometry.js" type="text/javascript"></script>
    <script src="script/viewer/collision.js" type="text/javascript"></script>
    <script src="script/viewer/objects.js" type="text/javascript"></script>
    <script src="script/viewer/gap.js" type="text/javascript"></script>
    <script src="script/viewer/create_rendered_obj.js" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/OBJExporter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/ColladaExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.min.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let orthoCamera, perspectiveCamera;
        let raycaster, mouse;
        let loadedObject = null;
        let loadedExtras = [];
        let loadedBillboards = [];
        let loadedFluids = [];
        let intersected = null;
        let lastFrame = null;
        let loader;

        const { decompressSync } = fflate;

        // --- Core Functions ---

        function hideFTTSplash() {
            const splash = document.getElementById("ftt_splash");
            if (splash) {
                splash.style.opacity = 0;
                setTimeout(() => {
                    const splash = document.getElementById("ftt_splash");
                    if (splash) {
                        splash.remove();
                    }
                }, 500);
            }
        }

        function showFTTWarning() {
            document.getElementById("ftt_warning").removeAttribute("hidden");
        }

        async function copyThreeScreenshot(renderer, scene, camera) {
            // 1. Render the scene
            renderer.render(scene, camera);

            // 2. Get the canvas
            const sourceCanvas = renderer.domElement;

            const w = sourceCanvas.width;
            const h = sourceCanvas.height;

            // 2. Create an offscreen canvas to draw screenshot + text
            const canvas = document.createElement("canvas");
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext("2d");

            // 3. Draw the rendered Three.js canvas
            ctx.drawImage(sourceCanvas, 0, 0, w, h);

            // 4. Draw watermark (bottom-right)
            const fontSize = Math.floor(h * 0.04);      // 4% of image height
            ctx.font = `${fontSize}px sans-serif`;
            ctx.fillStyle = "rgba(255, 255, 255, 0.85)"; // watermark color
            ctx.textBaseline = "bottom";
            ctx.textAlign = "right";

            const padding = Math.floor(fontSize * 0.6);

            ctx.fillText("Donk Viewer", w - padding, h - padding - 20);
            const fontSize2 = Math.floor(h * 0.02);      // 2% of image height
            ctx.font = `${fontSize2}px sans-serif`;
            ctx.fillText("theballaam96.github.io/donk_viewer", w - padding, h - padding);


            // 3. Convert canvas to Blob (PNG)
            const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/png"));

            if (!blob) {
                console.error("Unable to capture screenshot blob.");
                return;
            }

            try {
                // 4. Write blob to clipboard as an image
                await navigator.clipboard.write([
                    new ClipboardItem({ "image/png": blob })
                ]);
                window.createToast("Screenshot copied to clipboard", "success-subtle");
            } catch (err) {
                console.error("Clipboard error:", err);
            }
        }

        async function init() {
            // ROM load
            const isLoaded = await loadStoredFile();
            if (isLoaded) {
                // Stored file was loaded, you can start your application/emulator
                console.log("App ready with loaded data.");
            } else {
                // No stored file, prompt the user to load one
                console.log("App ready, awaiting file selection.");
                showFTTWarning();
            }
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);
            loadBackground();
            const aspect = window.innerWidth / window.innerHeight;
            perspectiveCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 100000);
            const frustumSize = 5;
            orthoCamera = new THREE.OrthographicCamera(
                (frustumSize * aspect) / -2,
                (frustumSize * aspect) / 2,
                frustumSize / 2,
                -frustumSize / 2,
                -100000,
                100000
            );
            renderer = new THREE.WebGLRenderer({ antialias: true });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera = perspectiveCamera;
            camera.position.set(0, 1, 3);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            scene.add(new THREE.DirectionalLight(0xffffff, 0.4));

            // Raycasting setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event Listeners
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMeshClick);

            // Load a default demo object
            if (isLoaded) {
                window.renderHandler(true);  // Temp
                window.renderHandler(false);
                setTimeout(() => {
                    hideFTTSplash();
                }, 500);
            }
            
            animate();
        }

        function toggleCamera() {
            const ortho = document.getElementById("ortho_camera").checked;
            // Save position & rotation so switching feels seamless
            const pos = camera.position.clone();
            const rot = camera.rotation.clone();

            // Switch camera reference
            camera = ortho ? orthoCamera : perspectiveCamera;
            camera.position.copy(pos);
            camera.rotation.copy(rot);

            // Update controls to track new camera
            controls.object = camera;
            controls.update();
            console.log(`Updating camera to ${ortho ? 'Orthographic' : 'Perspective'}`)
        }
        window.toggleCamera = toggleCamera;

        function animate(time) { // <-- The function is defined here
            requestAnimationFrame(animate);
            controls.update();
            const update_sprites = document.getElementById("animate_sprites").checked;
            loadedBillboards.forEach(b => {
                if (b.animated && update_sprites) {
                    if (time - b.lastFrameTime > b.frameInterval) {
                        b.currentFrame = (b.currentFrame + 1) % b.frames.length;
                        b.material.map = b.frames[b.currentFrame];
                        b.lastFrameTime = time;
                    }
                }
                b.mesh.lookAt(camera.position);
            })
            const frame = Math.floor((time / 1000) * 30);
            loadedFluids.forEach((f, index) => {
                if (update_sprites && (frame !== lastFrame) && false) {
                    f.userData.positions.array.forEach((v, i, arr) => {
                        if (i % 3 === 1) {
                            const [new_x, new_y, new_z] = window.animateFluidPoint(arr[i - 1], arr[i], arr[i + 1], f.userData);
                            arr[i - 1] = new_x;
                            arr[i] = new_y;
                            arr[i + 1] = new_z;
                        }
                    });
                    f.userData.positions.needsUpdate = true;
                    f.userData.fluid_vars.timer_0 += f.userData.fluid_vars.diff_0;
                    f.userData.fluid_vars.timer_1 += f.userData.fluid_vars.diff_1;
                    f.userData.fluid_vars.counter_38 += f.userData.fluid_vars.counter_diff_x;
                    f.userData.fluid_vars.counter_3c += f.userData.fluid_vars.counter_diff_z;
                    /*if (index == 0) {
                        console.log(f.userData.fluid_vars.timer_0);
                        console.log(f.userData.fluid_vars.timer_1);
                    }*/
                }
            })
            lastFrame = frame;
            renderer.render(scene, camera);
        }

        // --- OBJ File Loading ---

        function loadOBJ(objText, resetCamera) {
            // 1. Cleanup previous model (keep this section)
            if (loadedObject) {
                scene.remove(loadedObject);
                loadedObject.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            if (loadedExtras) {
                if (loadedExtras.length > 0) {
                    loadedExtras.forEach(extra => {
                        scene.remove(extra);
                        extra.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    })
                }
                loadedExtras = [];
            }
            loadedBillboards = [];
            loadedFluids = [];

            try {
                loader = new THREE.OBJLoader();
                loadedObject = loader.parse(objText);

                // --- CORE FIX FOR VERTEX COLOR SHARING ---
                loadedObject.traverse(function(child) {
                    if (child.isMesh) {
                        const geometry = child.geometry;

                        // 1. Un-Index the Geometry
                        // This forces every face to have its own unique set of vertices,
                        // preventing the GPU from blending colors across the edges.
                        if (geometry.index) {
                            geometry.toNonIndexed(); // Duplicates vertices for hard edges
                        }
                        
                        // 2. Compute Normals (essential after un-indexing for good shading)
                        geometry.computeVertexNormals();

                        // 3. Apply the Material
                        child.material = new THREE.MeshPhongMaterial({ 
                            color: 0xffffff,          // White base color
                            vertexColors: true,       // ⬅️ Keep this, but now the vertices are unique per face
                            transparent: true,        // Enable transparency support
                            opacity: 1.0,             // Default opacity
                            side: document.getElementById("ortho_camera").checked ? THREE.FrontSide : THREE.DoubleSide,    // Good for viewing translucent objects
                            wireframe: document.getElementById("wf_selector").checked,
                        });
                        child.name = 'LoadedMesh';
                    }
                });
                // --- END CORE FIX ---
                scene.add(loadedObject);
                if (resetCamera) {
                    centerModel();
                }

            } catch (error) {
                console.error("Error parsing OBJ file:", error);
            }
        }
        window.loadOBJ = loadOBJ;

        function addToScene(list) {
            list.forEach(item => {
                scene.add(item);
            })
            loadedExtras = loadedExtras.concat(list);
        }
        window.addToScene = addToScene;

        function addToSceneBillboards(list) {
            addToScene(list.map(b => b.mesh));
            loadedBillboards = loadedBillboards.concat(list);
        }
        window.addToSceneBillboards = addToSceneBillboards;
        
        function addToSceneFluids(list) {
            addToScene(list);
            loadedFluids = loadedFluids.concat(list);
        }
        window.addToSceneFluids = addToSceneFluids;

        function addObjects(list) {
            list.forEach((obj_file, index) => {
                //console.log(`Loading obj ${index} of size 0x${obj_file.length.toString(16)}`)
                const loaded_f = loader.parse(obj_file);
                loadedExtras.push(loaded_f);
                scene.add(loaded_f);

                // --- CORE FIX FOR VERTEX COLOR SHARING ---
                loaded_f.traverse(function(child) {
                    if (child.isMesh) {
                        const geometry = child.geometry;

                        // 1. Un-Index the Geometry
                        // This forces every face to have its own unique set of vertices,
                        // preventing the GPU from blending colors across the edges.
                        if (geometry.index) {
                            geometry.toNonIndexed(); // Duplicates vertices for hard edges
                        }
                        
                        // 2. Compute Normals (essential after un-indexing for good shading)
                        geometry.computeVertexNormals();

                        // 3. Apply the Material
                        child.material = new THREE.MeshPhongMaterial({ 
                            color: 0xffffff,          // White base color
                            vertexColors: true,       // ⬅️ Keep this, but now the vertices are unique per face
                            transparent: true,        // Enable transparency support
                            opacity: 1.0,             // Default opacity
                            side: THREE.DoubleSide,    // Good for viewing translucent objects
                        });
                        child.name = `Object ${index}`;
                    }
                });
            })
        }
        window.addObjects = addObjects;
        
        window.rom_bytes;
        window.rom_dv;

        const DB_NAME = 'ROM_Store';
        const STORE_NAME = 'rom_data';
        const KEY = 'current_rom';
        const DB_VERSION = 1;

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.errorCode);
                    reject("Database error");
                };

                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };

                // This runs only when the DB is first created or the version is upgraded
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    // Create an object store to hold the ROM data
                    db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                };
            });
        }

        function setGlobalRomData(arrayBuffer) {
            window.rom_bytes = new Uint8Array(arrayBuffer);
            window.rom_dv = new DataView(arrayBuffer);
            detectVersion(window.rom_bytes);
            console.log("Global ROM data updated.");
        }

        async function loadStoredFile() {
            try {
                const db = await openDB();
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                
                const request = store.get(KEY);
                
                return new Promise((resolve) => {
                    request.onsuccess = (event) => {
                        const result = event.target.result;
                        if (result && result.data) {
                            console.log("Found stored file data. Loading...");
                            setGlobalRomData(result.data);
                            resolve(true);
                        } else {
                            console.log("No stored file data found.");
                            resolve(false);
                        }
                    };

                    request.onerror = (event) => {
                        console.error("Error loading data:", event.target.error);
                        resolve(false);
                    };
                });

            } catch (e) {
                console.error("IndexedDB operation failed during load:", e);
                return false;
            }
        }

        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const arrayBuffer = await file.arrayBuffer();

            setGlobalRomData(arrayBuffer);

            try {
                const db = await openDB();
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);

                const dataToStore = { 
                    id: KEY, 
                    data: arrayBuffer 
                };

                const request = store.put(dataToStore);

                request.onsuccess = () => {
                    console.log("File data (", (arrayBuffer.byteLength / (1024 * 1024)).toFixed(2), "MB) stored successfully in IndexedDB.");
                };

                request.onerror = (event) => {
                    console.error("Error storing data:", event.target.error);
                    alert("Could not store file in browser. The browser may have run out of storage space.");
                };

            } catch (e) {
                console.error("IndexedDB operation failed:", e);
            }

            window.rom_bytes = new Uint8Array(arrayBuffer);
            const valid = window.detectVersion(window.rom_bytes);
            window.rom_dv = new DataView(arrayBuffer);
            window.resetGaps();
            window.renderHandler(false);
            window.renderHandler(false);
            if (valid) {
                hideFTTSplash();
            }
        }

        // --- Interaction (Clickable Meshes) ---
        let selectedEdges = null;

        function highlightEdges(ref_object) {
            if (selectedEdges) {
                scene.remove(selectedEdges);
                selectedEdges = null;
            }

            if (!ref_object) {
                return;
            }

            const edges = new THREE.EdgesGeometry(ref_object.geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
            );
            line.position.copy(ref_object.position);
            selectedEdges = line;
            scene.add(selectedEdges);
        }

        function onMeshClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Determine objects to check (all children of the loaded object)
            const intersects = raycaster.intersectObjects(scene.children.filter(k => k != loadedObject), false);

            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                highlightEdges(hitMesh);
                window.populateExtraData(hitMesh);
            } else {
                // No object hit, deselect
                highlightEdges(null);
            }
        }

        function setCookie(name, value, days = 365) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            const expires = "expires=" + date.toUTCString();
            document.cookie = `${name}=${encodeURIComponent(value)}; ${expires}; path=/`;
        }

        function getCookie(name) {
            const cookies = document.cookie.split(";").map(c => c.trim());
            for (const c of cookies) {
                if (c.startsWith(name + "=")) {
                    return decodeURIComponent(c.substring(name.length + 1));
                }
            }
            return null;
        }

        function loadBackground() {
            const saved = getCookie("backgroundColor");
            if (saved) {
                document.getElementById("color_picker").value = saved;
                scene.background = new THREE.Color(saved);
            }
        }

        document.getElementById("color_picker")?.addEventListener("input", function () {
            setCookie("backgroundColor", this.value);
            scene.background = new THREE.Color(this.value);
        });

        document.getElementById("snapshot_scene").addEventListener("click", () => {
            copyThreeScreenshot(renderer, scene, camera);
        });

        // --- Utility Functions ---
        
        function centerModel() {
            if (!loadedObject) return;

            // Compute bounding box
            const box = new THREE.Box3().setFromObject(loadedObject);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            //
            // 1. Center object on X/Z, place its base on Y=0
            //
            loadedObject.position.x -= center.x;
            loadedObject.position.z -= center.z;
            loadedObject.position.y -= box.min.y;

            //
            // 2. Update controls target
            //
            const objectCenter = new THREE.Vector3(0, size.y / 2, 0);
            controls.target.copy(objectCenter);

            //
            // 3. Adjust camera based on type
            //
            const maxDim = Math.max(size.x, size.z, size.y);

            if (camera.isOrthographicCamera) {
                camera.position.set(0, maxDim * 2, 0);
                camera.lookAt(objectCenter);

                // Fit orthographic frustum to bounding box AND viewport
                const aspect = renderer.domElement.clientWidth / renderer.domElement.clientHeight;
                const half = maxDim * 0.5;

                if (aspect >= 1) {
                    // Wide viewport → widen left/right
                    camera.left   = -half * aspect;
                    camera.right  =  half * aspect;
                    camera.top    =  half;
                    camera.bottom = -half;
                } else {
                    // Tall viewport → increase top/bottom
                    camera.left   = -half;
                    camera.right  =  half;
                    camera.top    =  half / aspect;
                    camera.bottom = -half / aspect;
                }

                camera.updateProjectionMatrix();

            } else {
                //
                // PERSPECTIVE CAMERA — standard angled view
                //
                const distance = maxDim * 1.5;
                camera.position.set(0, size.y * 0.5, distance);
                camera.lookAt(objectCenter);
            }

            controls.update();
        }


        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;

            // Update both cameras
            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();

            const frustumSize = 5;
            orthoCamera.left = (frustumSize * aspect) / -2;
            orthoCamera.right = (frustumSize * aspect) / 2;
            orthoCamera.top = frustumSize / 2;
            orthoCamera.bottom = -frustumSize / 2;
            orthoCamera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        document.getElementById('export_obj').onclick = () => {
            const exporter = new THREE.OBJExporter();
            const result = exporter.parse(scene);
            const blob = new Blob([result], { type: 'text/plain' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'scene.obj';
            link.click();
        };
		
        document.getElementById('export_dae').onclick = () => {
			const exporter = new THREE.ColladaExporter();
			const { data, textures } = exporter.parse(scene);
			const blob = new Blob([data], { type: 'text/xml' });
			const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'scene.dae';
            link.click();
        };

        document.getElementById('export_glb').onclick = () => {
            const exporter = new THREE.GLTFExporter();
            exporter.parse(scene, (gltf) => {
                const blob = new Blob([gltf], { type: 'model/gltf-binary' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'scene.glb';
                link.click();
            }, { binary: true }); // Use binary GLB format
        };

        // Initialize the application
        init();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
</body>
</html>