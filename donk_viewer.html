<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donk Viewer</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <meta name="description" content="" />
    <meta charset="UTF-8">
    <!-- Discord -->
    <meta content="Donk Viewer" property="og:title" />
    <meta content="DK64 Map Viewer with various controls on properties." property="og:description" />
    <meta content="DK64 Utils" property="og:site_name" />
    <meta content="https://raw.githubusercontent.com/theballaam96/theballaam96.github.io/master/assets/head.png" property="og:image" />

    <link rel="stylesheet" href="//code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #versionFlag img {
            width: 24px;
            height: auto;
            vertical-align: middle;
        }
        #trigger_grouping div, #rendering_options div {
            width: 50%;
        }
    </style>
</head>
<body>
    <div class="position-absolute bottom-0 start-0">
        <div class="card p-2 ms-4 mb-2 me-2 d-none" id="extra_data">
            <div class="d-flex pb-1" style="border-bottom: 1px solid gray">
                <div id="extra_data_name" class="flex-grow-1 fw-bold me-2"></div>
                <button type="button" class="btn-close" id="extra_data_close" aria-label="Close"></button>
            </div>
            <div id="extra_data_info" class="p-2" style="font-size: 0.8rem">

            </div>
        </div>
        <div class="card p-2 mb-4 ms-4 me-2 mt-2">
            <div class="d-flex justify-content-between mb-2 pb-1" style="border-bottom: 1px solid gray">
                <div class="fw-bolder">DonkViewer</div>
                <small>v2.0</small>
            </div>
            <div>Made by Ballaam</div>
            <div style="font-size: 0.8rem">Contributions from:
                <ul class="mb-0 ps-3">
                    <li>ALinkToTheFuture</li>
                    <li>ZeldaBoy14</li>
                </ul>
            </div>
        </div>
    </div>
    <div class="position-absolute top-0 end-0">
        <div class="card p-3 mt-4 me-4 ms-2 mb-2" style="max-width: 500px;">
            <div class="ms-auto">
                <button class="btn btn-sm" id="toggle_visibility" title="Maximize/Minimize">
                    <i class="fa-solid fa-minimize"></i>
                </button>
            </div>
            <div id="controls_content">
                <div class="mb-2">
                    <small>ROM File</small>
                    <div class="input-group flex-nowrap" id="fileUploadButton">
                        <button class="btn btn-secondary">
                            <i class="fa-solid fa-file-arrow-up"></i>
                        </button>
                        <span class="form-control" id="fileUploadText">Choose a file</span>
                    </div>
                    <div hidden>
                        <input type="file" id="fileInput" accept=".z64" hidden>
                    </div>
                </div>
                <div class="mb-2">
                    <label for="map_id_selector">Map</label>
                    <select id="map_id_selector" class="form-select change-reload double-reload force-camera"></select>
                </div>
                <div class="mb-2">
                    <label for="bg_selector">Backdrop</label>
                    <select id="bg_selector" class="form-select change-reload"></select>
                </div>
                <div class="mb-2">
                    <label for="obj_selector">Objects</label>
                    <select id="obj_selector" class="form-select change-reload"></select>
                </div>
                <div id="progress_text" hidden>

                </div>
                <div class="mb-2">
                    <label for="extra_marker_dropdown">Internal Markers</label>
                    <div class="dropdown">
                        <button 
                            class="btn btn-secondary dropdown-toggle" 
                            type="button" 
                            id="multiSelectDropdown" 
                            data-bs-toggle="dropdown"
                            data-bs-auto-close="outside"
                            aria-expanded="false">
                            Select Options
                        </button>
                        <ul class="dropdown-menu p-2" aria-labelledby="multiSelectDropdown" style="width: 200px;" id="extra_marker_dropdown">
                        </ul>
                    </div>
                </div>
                <div class="mb-2">
                    <label for="rendering_options">Rendering Options</label>
                    <div class="d-flex flex-wrap" id="rendering_options">
                        <div class="form-check form-switch py-2">
                            <input class="form-check-input click-reload" type="checkbox" role="switch" id="wf_selector">
                            <label class="form-check-label" for="wf_selector">Wireframe Mode</label>
                        </div>
                        <div class="form-check form-switch py-2">
                            <input class="form-check-input click-reload force-camera double-reload" type="checkbox" role="switch" id="ortho_camera">
                            <label class="form-check-label" for="ortho_camera">Orthographic Camera</label>
                        </div>
                        <div class="form-check form-switch py-2">
                            <input class="form-check-input" type="checkbox" role="switch" id="animate_sprites" checked>
                            <label class="form-check-label" for="animate_sprites">Animate Sprites</label>
                        </div>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                        Export Scene
                    </button>
                    <ul class="dropdown-menu">
                        <li><a class="dropdown-item" href="#" id="export_obj">To OBJ</a></li>
						<li><a class="dropdown-item" href="#" id="export_dae">To DAE</a></li>
                        <li><a class="dropdown-item" href="#" id="export_glb">To GLB/glTF</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="card p-2 ms-2 d-none" id="gaps_fyi" style="max-width: 500px;">
            <h3>PSA</h3>
            <p>
                This view is experimental and may highlight some gaps that don't exist or miss some gaps that do exist.
                Automatically calculating where the gaps are in complex 3D geometry is an incredibly complicated
                process that this viewer does it's best job at showing. The estimated rate of failure with this viewer is &lt;1%.
            </p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://unpkg.com/fflate@0.8.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>
    <script src="https://twemoji.maxcdn.com/v/latest/twemoji.min.js"></script>
    <script src="script/viewer/lib.js" type="text/javascript"></script>
    <script src="script/viewer/texture.js" type="text/javascript"></script>
    <script src="script/viewer/ui.js" type="text/javascript"></script>
    <script src="script/viewer/vtx.js" type="text/javascript"></script>
    <script src="script/viewer/parser.js" type="text/javascript"></script>
    <script src="script/viewer/rom_handler.js" type="text/javascript"></script>
    <script src="script/viewer/geometry.js" type="text/javascript"></script>
    <script src="script/viewer/collision.js" type="text/javascript"></script>
    <script src="script/viewer/objects.js" type="text/javascript"></script>
    <script src="script/viewer/gap.js" type="text/javascript"></script>
    <script src="script/viewer/create_rendered_obj.js" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/OBJExporter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/ColladaExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.min.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let orthoCamera, perspectiveCamera;
        let raycaster, mouse;
        let loadedObject = null;
        let loadedExtras = [];
        let loadedBillboards = [];
        let intersected = null;
        let loader;

        const { decompressSync } = fflate;

        // --- Core Functions ---

        async function init() {
            // ROM load
            const isLoaded = await loadStoredFile();
            if (isLoaded) {
                // Stored file was loaded, you can start your application/emulator
                console.log("App ready with loaded data.");
            } else {
                // No stored file, prompt the user to load one
                console.log("App ready, awaiting file selection.");
            }
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333); 
            const aspect = window.innerWidth / window.innerHeight;
            perspectiveCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 100000);
            const frustumSize = 5;
            orthoCamera = new THREE.OrthographicCamera(
                (frustumSize * aspect) / -2,
                (frustumSize * aspect) / 2,
                frustumSize / 2,
                -frustumSize / 2,
                -100000,
                100000
            );
            renderer = new THREE.WebGLRenderer({ antialias: true });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera = perspectiveCamera;
            camera.position.set(0, 1, 3);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            scene.add(new THREE.DirectionalLight(0xffffff, 0.4));

            // Raycasting setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event Listeners
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMeshClick);

            // Load a default demo object
            if (isLoaded) {
                window.renderHandler(true);  // Temp
                window.renderHandler(false);
            }
            
            animate();
        }

        function toggleCamera() {
            const ortho = document.getElementById("ortho_camera").checked;
            // Save position & rotation so switching feels seamless
            const pos = camera.position.clone();
            const rot = camera.rotation.clone();

            // Switch camera reference
            camera = ortho ? orthoCamera : perspectiveCamera;
            camera.position.copy(pos);
            camera.rotation.copy(rot);

            // Update controls to track new camera
            controls.object = camera;
            controls.update();
            console.log(`Updating camera to ${ortho ? 'Orthographic' : 'Perspective'}`)
        }
        window.toggleCamera = toggleCamera;

        function animate(time) { // <-- The function is defined here
            requestAnimationFrame(animate);
            controls.update();
            const update_sprites = document.getElementById("animate_sprites").checked;
            loadedBillboards.forEach(b => {
                if (b.animated && update_sprites) {
                    if (time - b.lastFrameTime > b.frameInterval) {
                        b.currentFrame = (b.currentFrame + 1) % b.frames.length;
                        b.material.map = b.frames[b.currentFrame];
                        b.lastFrameTime = time;
                    }
                }
                b.mesh.lookAt(camera.position);
            })
            renderer.render(scene, camera);
        }

        // --- OBJ File Loading ---

        function loadOBJ(objText, resetCamera) {
            // 1. Cleanup previous model (keep this section)
            if (loadedObject) {
                scene.remove(loadedObject);
                loadedObject.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            if (loadedExtras) {
                if (loadedExtras.length > 0) {
                    loadedExtras.forEach(extra => {
                        scene.remove(extra);
                        extra.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    })
                }
                loadedExtras = [];
            }
            loadedBillboards = [];

            try {
                loader = new THREE.OBJLoader();
                loadedObject = loader.parse(objText);

                // --- CORE FIX FOR VERTEX COLOR SHARING ---
                loadedObject.traverse(function(child) {
                    if (child.isMesh) {
                        const geometry = child.geometry;

                        // 1. Un-Index the Geometry
                        // This forces every face to have its own unique set of vertices,
                        // preventing the GPU from blending colors across the edges.
                        if (geometry.index) {
                            geometry.toNonIndexed(); // Duplicates vertices for hard edges
                        }
                        
                        // 2. Compute Normals (essential after un-indexing for good shading)
                        geometry.computeVertexNormals();

                        // 3. Apply the Material
                        child.material = new THREE.MeshPhongMaterial({ 
                            color: 0xffffff,          // White base color
                            vertexColors: true,       // ⬅️ Keep this, but now the vertices are unique per face
                            transparent: true,        // Enable transparency support
                            opacity: 1.0,             // Default opacity
                            side: THREE.DoubleSide,    // Good for viewing translucent objects
                            wireframe: document.getElementById("wf_selector").checked,
                        });
                        child.name = 'LoadedMesh';
                    }
                });
                // --- END CORE FIX ---
                scene.add(loadedObject);
                if (resetCamera) {
                    centerModel();
                }

            } catch (error) {
                console.error("Error parsing OBJ file:", error);
            }
        }
        window.loadOBJ = loadOBJ;

        function addToScene(list) {
            list.forEach(item => {
                scene.add(item);
            })
            loadedExtras = loadedExtras.concat(list);
        }
        window.addToScene = addToScene;

        function addToSceneBillboards(list) {
            addToScene(list.map(b => b.mesh));
            loadedBillboards = loadedBillboards.concat(list);
        }
        window.addToSceneBillboards = addToSceneBillboards;

        function addObjects(list) {
            list.forEach((obj_file, index) => {
                //console.log(`Loading obj ${index} of size 0x${obj_file.length.toString(16)}`)
                const loaded_f = loader.parse(obj_file);
                loadedExtras.push(loaded_f);
                scene.add(loaded_f);

                // --- CORE FIX FOR VERTEX COLOR SHARING ---
                loaded_f.traverse(function(child) {
                    if (child.isMesh) {
                        const geometry = child.geometry;

                        // 1. Un-Index the Geometry
                        // This forces every face to have its own unique set of vertices,
                        // preventing the GPU from blending colors across the edges.
                        if (geometry.index) {
                            geometry.toNonIndexed(); // Duplicates vertices for hard edges
                        }
                        
                        // 2. Compute Normals (essential after un-indexing for good shading)
                        geometry.computeVertexNormals();

                        // 3. Apply the Material
                        child.material = new THREE.MeshPhongMaterial({ 
                            color: 0xffffff,          // White base color
                            vertexColors: true,       // ⬅️ Keep this, but now the vertices are unique per face
                            transparent: true,        // Enable transparency support
                            opacity: 1.0,             // Default opacity
                            side: THREE.DoubleSide,    // Good for viewing translucent objects
                        });
                        child.name = `Object ${index}`;
                    }
                });
            })
        }
        window.addObjects = addObjects;
        
        window.rom_bytes;
        window.rom_dv;

        const DB_NAME = 'ROM_Store';
        const STORE_NAME = 'rom_data';
        const KEY = 'current_rom';
        const DB_VERSION = 1;

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.errorCode);
                    reject("Database error");
                };

                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };

                // This runs only when the DB is first created or the version is upgraded
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    // Create an object store to hold the ROM data
                    db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                };
            });
        }

        function setGlobalRomData(arrayBuffer) {
            window.rom_bytes = new Uint8Array(arrayBuffer);
            window.rom_dv = new DataView(arrayBuffer);
            detectVersion(window.rom_bytes);
            console.log("Global ROM data updated.");
        }

        async function loadStoredFile() {
            try {
                const db = await openDB();
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                
                const request = store.get(KEY);
                
                return new Promise((resolve) => {
                    request.onsuccess = (event) => {
                        const result = event.target.result;
                        if (result && result.data) {
                            console.log("Found stored file data. Loading...");
                            setGlobalRomData(result.data);
                            resolve(true);
                        } else {
                            console.log("No stored file data found.");
                            resolve(false);
                        }
                    };

                    request.onerror = (event) => {
                        console.error("Error loading data:", event.target.error);
                        resolve(false);
                    };
                });

            } catch (e) {
                console.error("IndexedDB operation failed during load:", e);
                return false;
            }
        }

        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const arrayBuffer = await file.arrayBuffer();

            setGlobalRomData(arrayBuffer);

            try {
                const db = await openDB();
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);

                const dataToStore = { 
                    id: KEY, 
                    data: arrayBuffer 
                };

                const request = store.put(dataToStore);

                request.onsuccess = () => {
                    console.log("File data (", (arrayBuffer.byteLength / (1024 * 1024)).toFixed(2), "MB) stored successfully in IndexedDB.");
                };

                request.onerror = (event) => {
                    console.error("Error storing data:", event.target.error);
                    alert("Could not store file in browser. The browser may have run out of storage space.");
                };

            } catch (e) {
                console.error("IndexedDB operation failed:", e);
            }

            window.rom_bytes = new Uint8Array(arrayBuffer);
            window.detectVersion(window.rom_bytes);
            window.rom_dv = new DataView(arrayBuffer);
            window.resetGaps();
            window.renderHandler(false);
            window.renderHandler(false);
        }

        // --- Interaction (Clickable Meshes) ---
        let selectedEdges = null;

        function highlightEdges(ref_object) {
            if (selectedEdges) {
                scene.remove(selectedEdges);
                selectedEdges = null;
            }

            if (!ref_object) {
                return;
            }

            const edges = new THREE.EdgesGeometry(ref_object.geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
            );
            line.position.copy(ref_object.position);
            selectedEdges = line;
            scene.add(selectedEdges);
        }

        function onMeshClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Determine objects to check (all children of the loaded object)
            const intersects = raycaster.intersectObjects(scene.children.filter(k => k != loadedObject), false);

            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                highlightEdges(hitMesh);
                window.populateExtraData(hitMesh);
            } else {
                // No object hit, deselect
                highlightEdges(null);
            }
        }

        // --- Utility Functions ---
        
        function centerModel() {
            if (!loadedObject) return;
            
            const box = new THREE.Box3().setFromObject(loadedObject);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            // Center model and put it on the plane (Y=0)
            loadedObject.position.sub(center).add(new THREE.Vector3(0, size.y / 2, 0));
            
            // Adjust camera to view the model
            controls.target.copy(loadedObject.position);
            const distance = Math.max(size.x, size.y, size.z) * 1.5;
            camera.position.copy(loadedObject.position).add(new THREE.Vector3(0, size.y * 0.5, distance));
            controls.update();
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;

            // Update both cameras
            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();

            const frustumSize = 5;
            orthoCamera.left = (frustumSize * aspect) / -2;
            orthoCamera.right = (frustumSize * aspect) / 2;
            orthoCamera.top = frustumSize / 2;
            orthoCamera.bottom = -frustumSize / 2;
            orthoCamera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        document.getElementById('export_obj').onclick = () => {
            const exporter = new THREE.OBJExporter();
            const result = exporter.parse(scene);
            const blob = new Blob([result], { type: 'text/plain' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'scene.obj';
            link.click();
        };
		
        document.getElementById('export_dae').onclick = () => {
			const exporter = new THREE.ColladaExporter();
			const { data, textures } = exporter.parse(scene);
			const blob = new Blob([data], { type: 'text/xml' });
			const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'scene.dae';
            link.click();
        };

            // === GLB Export ===
        document.getElementById('export_glb').onclick = () => {
            const exporter = new THREE.GLTFExporter();
            exporter.parse(scene, (gltf) => {
                const blob = new Blob([gltf], { type: 'model/gltf-binary' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'scene.glb';
                link.click();
            }, { binary: true }); // Use binary GLB format
        };

        // Initialize the application
        init();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
</body>
</html>